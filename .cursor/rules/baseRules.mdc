---
alwaysApply: true
---

ƒê√¢y l√† t√†i li·ªáu ki·∫øn tr√∫c n·ªôi b·ªô.

---

## **HI·∫æN PH√ÅP K·ª∏ THU·∫¨T D·ª∞ √ÅN**

**Version 1.0**

### **Ph·∫ßn I: Tri·∫øt l√Ω N·ªÅn t·∫£ng (The Constitution)**
*ƒê√¢y l√† la b√†n ƒë·ªãnh h∆∞·ªõng cho m·ªçi quy·∫øt ƒë·ªãnh. M·ªçi quy t·∫Øc b√™n d∆∞·ªõi ƒë·ªÅu ph·∫£i tu√¢n th·ªß Hi·∫øn ph√°p n√†y.*
- tr∆∞·ªõc khi l√†m m·ªçi b∆∞·ªõc ph·∫£i t√¨m ƒë∆∞·ª£c trong m√£ ngu·ªìn c√≥ ch·ªó n√†o c√≥ k·∫øt qu·∫£ gi·ªëng, ho·∫∑c t∆∞∆°ng t·ª± thu·ªôc ngu·ªìn uy t√≠n. h·ªèi nh·ªØng c√¢u h·ªèi tr·ª´u t∆∞·ª£ng t√¨m ki·∫øn th·ª©c trong m√£ v√≠ d·ª• r·ªìi suy ni·ªám c·ª• th·ªÉ . N·∫øu h·ªèi kh√¥ng th·∫•y, ph·∫£i grep l·∫ßn ki·∫øn th·ª©c b·∫±ng m·ªçi gi√°. ph·∫£i chu·∫©n b·ªã ƒë·∫ßy ƒë·ªß l√™n k·∫ø ho·∫°ch ch·∫Øc ch·∫Øn 100% th·ª±c hi·ªán kh√¥ng l·ªói m·ªõi l√†m, lu√¥n b·∫Øt ƒë·∫ßu s·ª≠a file `.feature` tr∆∞·ªõc khi s·ª≠a code , kh√¥ng ƒë·ªß kh·∫£ nƒÉng th√¨ b·ªè qua. M·ªçi m√£ code ƒë·ªÅu ph·∫£i commend ngu·ªìn @see ƒë·ªÉ ƒë·∫£m b·∫£o uy t√≠n, ch·∫•t l∆∞·ª£ng. 
> **T∆∞ duy c·ªët l√µi:** T·ªëi gi·∫£n ƒë·ªÉ T·ªëi ƒëa h√≥a Hi·ªáu qu·∫£.

**10 Nguy√™n t·∫Øc V√†ng:**

1.  **T·ªëi gi·∫£n** h∆°n Ph·ª©c t·∫°p
2.  **T·∫≠p trung** h∆°n Ph√¢n t√°n
3.  **Linh ho·∫°t** h∆°n D·∫≠p khu√¥n
4.  **Ch·∫•t l∆∞·ª£ng** h∆°n S·ªë l∆∞·ª£ng
5.  **B·ªë c·ª•c** ƒë·∫øn Chi ti·∫øt
6.  **T·ª± ƒë·ªông** h∆°n Th·ªß c√¥ng
7.  **Minh b·∫°ch** h∆°n Tinh x·∫£o
8.  **K·ª∑ lu·∫≠t** h∆°n Quy ∆∞·ªõc
9.  **Ti·∫øn h√≥a** h∆°n C√°ch m·∫°ng
10.  **C·ª• th·ªÉ** h∆°n M∆° h·ªì
---

### **Ph·∫ßn II: Ki·∫øn tr√∫c & Ngu·ªìn Ch√¢n L√Ω**

1.  **Ki·∫øn tr√∫c Domain-Driven Design (DDD):**
    *   **Quy t·∫Øc:** M·ªçi logic nghi·ªáp v·ª• ph·∫£i ƒë∆∞·ª£c t·ªï ch·ª©c theo c√°c `models` (domain). M·ªói `model` l√† m·ªôt module g·∫ßn nh∆∞ ƒë·ªôc l·∫≠p.
    *   **Giao ti·∫øp:** Giao ti·∫øp gi·ªØa c√°c model ph·∫£i th√¥ng qua `eventBus` n·ªôi b·ªô ƒë·ªÉ ƒë·∫£m b·∫£o kh·ªõp n·ªëi l·ªèng l·∫ªo. Giao ti·∫øp v·ªõi Client qua tRPC.

2.  **Ngu·ªìn Ch√¢n L√Ω (Single Source of Truth):**
    *   **C·∫•u tr√∫c D·ªØ li·ªáu:** Ngu·ªìn ch√¢n l√Ω l√† c√°c t·ªáp `.prisma` (v√≠ d·ª•: `models/user/user.prisma`).
    *   **T·ª± ƒë·ªông h√≥a:** `prisma-import` ƒë∆∞·ª£c d√πng ƒë·ªÉ h·ª£p nh·∫•t c√°c file `.prisma`. Sau ƒë√≥, `prisma-zod-generator` ƒë·ªçc file ƒë√£ h·ª£p nh·∫•t ƒë·ªÉ **t·ª± ƒë·ªông sinh ra c√°c Zod schema c∆° s·ªü**.
    *   **Nghi√™m c·∫•m:** Ch·ªânh s·ª≠a th·ªß c√¥ng c√°c file trong th∆∞ m·ª•c Zod ƒë∆∞·ª£c sinh ra t·ª± ƒë·ªông.

3.  **Th∆∞ m·ª•c `shared`:**
    *   **Quy t·∫Øc:** M·ªôt th√†nh ph·∫ßn (util, component,...) ch·ªâ ƒë∆∞·ª£c ƒë∆∞a v√†o `shared` khi n√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi **√≠t nh·∫•t 3 module kh√°c nhau** ho·∫∑c l√† m·ªôt ph·∫ßn c·ªët l√µi c·ªßa h·∫° t·∫ßng ·ª©ng d·ª•ng (trpc client, logger). Lu√¥n ∆∞u ti√™n gi·ªØ logic g·∫ßn v·ªõi n∆°i n√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng nh·∫•t.

4.  **Redis Queue System (BullMQ):**
    *   **Ki·∫øn tr√∫c:** S·ª≠ d·ª•ng BullMQ v·ªõi Redis l√†m message broker cho background job processing.
    *   **Ngu·ªìn ch√¢n l√Ω:** C·∫•u h√¨nh queue t·∫°i `models/queue/config.ts`, service t·∫°i `models/queue/queue.service.ts`.
    *   **Quy t·∫Øc:** 
        - M·ªçi long-running task ph·∫£i ƒë∆∞·ª£c chuy·ªÉn th√†nh queue job
        - Job data ph·∫£i extend t·ª´ `BaseJobData` interface
        - Worker ph·∫£i c√≥ progress tracking ƒë·ªÉ tr√°nh job lock issues
        - S·ª≠ d·ª•ng `QueueService` singleton ƒë·ªÉ qu·∫£n l√Ω queues v√† workers
        - Job timeout v√† retry ƒë∆∞·ª£c c·∫•u h√¨nh trong `QueueConfig`
    *   **Pattern:** Domain-specific queue services (v√≠ d·ª•: `KnowledgeQueueService`) wrap `QueueService` v·ªõi business logic

---
5. D·ªØ li·ªáu chung ƒë·ªÉ hi·ªÉu d·ª± √°n
- [C·∫•u tr√∫c th∆∞ m·ª•c](/core/docs/project-structure.md)
- [T√†i li·ªáu API](/core/docs/openapi.minimal.json)
- [C√°c g√≥i th∆∞ vi·ªán](/core/package.json)
- [zod schema shared](/core/shared/generated/zod/index.ts)
- [fabbrica](/core/shared/generated/fabbrica/index.ts)
- [package command](/package.json)
### **Ph·∫ßn III: Quy t·∫Øc Chi ti·∫øt cho t·ª´ng T·ªáp (Trong `models/{model-name}/`)**

*   **C·∫•u tr√∫c chung:**

    ```
    models/{model-name}/
    ‚îú‚îÄ‚îÄ __tests__/
    ‚îú‚îÄ‚îÄ {model-name}.prisma  # Ngu·ªìn Ch√¢n L√Ω cho model
    ‚îú‚îÄ‚îÄ input.ts             # "H·ª£p ƒë·ªìng" ƒë·∫ßu v√†o c·ªßa API
    ‚îú‚îÄ‚îÄ output.ts            # "H·ª£p ƒë·ªìng" ƒë·∫ßu ra c·ªßa API
    ‚îú‚îÄ‚îÄ service.ts           # Logic nghi·ªáp v·ª•
    ‚îú‚îÄ‚îÄ router.ts            # L·ªõp giao ti·∫øp API
    ‚îú‚îÄ‚îÄ meta.ts              # Metadata cho OpenAPI/MCP
    ‚îú‚îÄ‚îÄ queue/               # Redis Queue System (n·∫øu c·∫ßn)
    ‚îÇ   ‚îú‚îÄ‚îÄ queue.service.ts # Domain-specific queue service
    ‚îÇ   ‚îú‚îÄ‚îÄ {job-name}.worker.ts # Worker cho t·ª´ng lo·∫°i job
    ‚îÇ   ‚îî‚îÄ‚îÄ index.ts         # Export queue services
    ‚îî‚îÄ‚îÄ listener.ts (option)
    ‚îî‚îÄ‚îÄ event-bus.ts (option)
    ‚îî‚îÄ‚îÄ hooks.ts (option)
    ‚îî‚îÄ‚îÄ ui/component
        ‚îî‚îÄ‚îÄ component
        ‚îî‚îÄ‚îÄ page.tsx
    ‚îî‚îÄ‚îÄ README.md
    ‚îî‚îÄ‚îÄ ...


*   **Quy t·∫Øc cho t·ª´ng t·ªáp:**
- {model-name}.prisma: ƒê·ªãnh nghƒ©a model, quan h·ªá, v√† c√°c quy t·∫Øc to√†n v·∫πn d·ªØ li·ªáu (onDelete).
- input.ts: PH·∫¢I t√πy bi·∫øn schema cho t·ª´ng h√†nh vi nghi·ªáp v·ª•. KH√îNG d√πng schema action ƒë∆∞·ª£c sinh ra tr·ª±c -ti·∫øp. B·∫Øt ƒë·∫ßu b·∫±ng c√°ch import schema g·ªëc, sau ƒë√≥ d√πng .pick(), .extend(), .refine(). input.ts field ph·∫£i c√≥ description ƒë·ªÉ MCP hi·ªÉu
- output.ts: Vai tr√≤ ch√≠nh l√† re-export c√°c schema ƒë√£ ƒë∆∞·ª£c sinh ra (...Model, ...CompleteModel). Ch·ªâ t√πy bi·∫øn trong tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát c·∫ßn m·ªôt c·∫•u tr√∫c tr·∫£ v·ªÅ kh√°c ho√†n to√†n model. output ph·∫£i import t·ª´ core\shared\generated\zod ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n.

- service.ts: Ch·ª©a to√†n b·ªô business logic. ∆Øu ti√™n tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng Prisma ƒë·∫ßy ƒë·ªß. Ch·ªâ d√πng select khi c√≥ l√Ω do ch√≠nh ƒë√°ng v·ªÅ hi·ªáu su·∫•t/b·∫£o m·∫≠t v√† ph·∫£i c√≥ output schema t∆∞∆°ng ·ª©ng. ph·∫£i d√πng ctx prisma thay v√¨ import tr·ª±c ti·∫øp
- router.ts: L·ªõp giao ti·∫øp API, KH√îNG ch·ª©a business logic. B·∫Øt bu·ªôc PH·∫¢I c√≥ input, output, meta. ph·∫£i d√πng ctx input. v√† c·∫ßn c√≥ input (d√π l√† {} r·ªóng) ƒë·ªÉ MCP ho·∫°t ƒë·ªông
- meta.ts: Cung c·∫•p metadata cho trpc-openapi v√† c√°c c√¥ng c·ª• kh√°c. t√™n tool lu√¥n ph·∫£i d√∫ng c·∫•u tr√∫c {model}-{api}.meta description ph·∫£i k√®m c·∫•u tr√∫c return
- README.md: M√¥ t·∫£ ki·∫øn tr√∫c v√† lu·ªìng ho·∫°t ƒë·ªông ch√≠nh, KH√îNG ghi chi ti·∫øt tri·ªÉn khai.
Ghi ch√∫ v·ªÅ s·ª± linh ho·∫°t: V·ªõi c√°c module c·ª±c k·ª≥ ƒë∆°n gi·∫£n, c√≥ th·ªÉ g·ªôp file nh∆∞ng ph·∫£i ƒë∆∞·ª£c team ƒë·ªìng thu·∫≠n. ∆Øu ti√™n tu√¢n th·ªß c·∫•u tr√∫c chung.
- hook.ts: ∆Øu ti·ªÅn type trong prisma client
*   **Ghi ch√∫ v·ªÅ s·ª± linh ho·∫°t:** ƒê·ªëi v·ªõi c√°c module c·ª±c k·ª≥ ƒë∆°n gi·∫£n (v√≠ d·ª•: ch·ªâ c√≥ 1-2 thao t√°c CRUD), c√≥ th·ªÉ c√¢n nh·∫Øc g·ªôp logic v√†o m·ªôt s·ªë √≠t file h∆°n, mi·ªÖn l√† ƒë∆∞·ª£c s·ª± ƒë·ªìng thu·∫≠n c·ªßa team v√† ghi ch√∫ r√µ l√Ω do. Tuy nhi√™n, **∆∞u ti√™n tu√¢n th·ªß c·∫•u tr√∫c chung ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n**.
- listener.ts :L·∫Øng nghe c√°c s·ª± ki·ªán li√™n quan (event bus / message / emitter n·ªôi b·ªô)
- event-bus.ts Event bus ri√™ng bi·ªát v·ªõi eventBus (/core/sharedevent-bus/index.ts) d√πng chung
- queue/queue.service.ts: Domain-specific queue service, wrap QueueService v·ªõi business logic. PH·∫¢I extend BaseJobData cho job data, s·ª≠ d·ª•ng QueueService singleton
- queue/{job-name}.worker.ts: Worker x·ª≠ l√Ω job c·ª• th·ªÉ. PH·∫¢I c√≥ progress tracking ƒë·ªÉ tr√°nh job lock issues, extend TypedJob interface
- queue/index.ts: Export t·∫•t c·∫£ queue services v√† workers c·ªßa domain
---
- page.tsx Page ch√≠nh ƒë·ªÉ hi·ªÉn th·ªã (d√πng hook, g·ªçi API,...)
- ui/component N·∫øu l·ªõn, t√°ch th√™m component con
- type: t·∫•t c·∫£ khai b√°o type ƒë·ªÅu ph·∫£i ƒë·ªÉ trong n√†y
### **Ph·∫ßn IV: Quy t·∫Øc Testing**

1.  **Ch·∫•t l∆∞·ª£ng:** M·ªçi logic quan tr·ªçng v√† c√°c lu·ªìng nghi·ªáp v·ª• ch√≠nh ƒë·ªÅu ph·∫£i c√≥ test.
2.  **C·∫•u tr√∫c:** Tu√¢n th·ªß nghi√™m ng·∫∑t c·∫•u tr√∫c 3 l·ªõp:
    *   `1-unit/`: Test logic thu·∫ßn t√∫y. **PH·∫¢I MOCK** Prisma.
    *   `2-integration/`: Test t∆∞∆°ng t√°c v·ªõi DB th·∫≠t. **KH√îNG MOCK** Prisma.
    *   `3-e2e/`: Test to√†n b·ªô lu·ªìng nghi·ªáp v·ª•.
3.  **C√¥ng c·ª• & K·ª∑ lu·∫≠t:**
    *   S·ª≠ d·ª•ng `Testcontainers` ƒë·ªÉ t·∫°o m√¥i tr∆∞·ªùng DB nh·∫•t qu√°n cho Integration Test.
    *   S·ª≠ d·ª•ng `Fabbrica` v√† `@faker-js/faker` ƒë·ªÉ t·∫°o d·ªØ li·ªáu test m·ªôt c√°ch t·ª± ƒë·ªông v√† c√≥ c·∫•u tr√∫c.

---

### **Ph·∫ßn V: T√†i li·ªáu & Giao di·ªán**

1.  **T√†i li·ªáu API:**
    *   T√†i li·ªáu OpenAPI t·∫°i `/api/openapi.json` ƒë∆∞·ª£c **t·ª± ƒë·ªông sinh ra** b·ªüi `trpc-openapi` v√† kh√¥ng ƒë∆∞·ª£c ch·ªânh s·ª≠a b·∫±ng tay.
2.  **Giao di·ªán (UI):**
    *   T√°ch bi·ªát r√µ r√†ng gi·ªØa **Page Components** (qu·∫£n l√Ω state, g·ªçi API) v√† **UI Components** (nh·∫≠n props, hi·ªÉn th·ªã).
    *   S·ª≠ d·ª•ng c√°c custom hooks (`hooks.ts`) ƒë·ªÉ ƒë√≥ng g√≥i v√† t√°i s·ª≠ d·ª•ng client-side logic.
3.  **Logger:**
    *   S·ª≠ d·ª•ng logger (Pino) ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh s·∫µn trong `shared/utils/logger` cho m·ªçi ho·∫°t ƒë·ªông ghi log ·ªü backend.

### Ph·∫ßn VI :V√≠ d·ª• tham kh·∫£o

#### **`user.prisma` (Ngu·ªìn Ch√¢n L√Ω)**
// models/user/user.prisma
```prisma
import { Post } from "../post/post.prisma"

model User {
  id        String    @id @default(cuid())
  email     String    @unique
  name      String?
  role      Role      @default(USER)
  createdAt DateTime  @default(now())
  posts     Post[]    @relation(onDelete: Cascade)
}
enum Role { USER, ADMIN }
```

#### **`input.ts` (Linh ho·∫°t > D·∫≠p khu√¥n)**

*Quy t·∫Øc: T√πy bi·∫øn schema cho t·ª´ng h√†nh vi nghi·ªáp v·ª•. KH√îNG d√πng schema action ƒë∆∞·ª£c sinh ra tr·ª±c ti·∫øp.*

```typescript

// models/user/input.ts
import { z } from 'zod';
import { UserModel } from '@/zod/generated/user'; // Import schema g·ªëc ƒë·ªÉ k·∫ø th·ª´a

// V√≠ d·ª• 1: Schema cho h√†nh vi "ƒêƒÉng k√Ω" (Gi·ªØ nguy√™n)
export const registerUserSchema = UserModel
  .pick({ email: true, name: true })
  .extend({
    email: z.string().email("Email kh√¥ng h·ª£p l·ªá."),
    name: z.string().min(2, "T√™n ph·∫£i c√≥ √≠t nh·∫•t 2 k√Ω t·ª±."),
  });

// V√≠ d·ª• 2: Schema cho h√†nh vi "C·∫≠p nh·∫≠t vai tr√≤"
// (S·ª≠a l·∫°i ƒë·ªÉ t∆∞·ªùng minh h∆°n, kh√¥ng d√πng .shape tr·ª±c ti·∫øp)
export const updateUserRoleSchema = z.object({
  userId: z.string().cuid("ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá."),
  // T√°i s·ª≠ d·ª•ng enum schema ƒë√£ ƒë∆∞·ª£c sinh ra m·ªôt c√°ch an to√†n
  role: z.nativeEnum(Role),
});

// Th√™m export type ƒë·ªÉ service s·ª≠ d·ª•ng, tƒÉng t√≠nh minh b·∫°ch
export type RegisterUserInput = z.infer<typeof registerUserSchema>;
export type UpdateUserRoleInput = z.infer<typeof updateUserRoleSchema>;
```

#### **`output.ts` (T·ªëi gi·∫£n & T·ª± ƒë·ªông)**
// models/user/output.ts
```typescript
import { UserModel as BaseUserModel } from '@/zod/generated/user';

// Re-export c√°c schema ƒë∆∞·ª£c sinh ra t·ª± ƒë·ªông t·ª´ `zod/generated`.
// ƒê√¢y l√† c√°ch l√†m cho 95% c√°c tr∆∞·ªùng h·ª£p.
export {
  UserModel,
  UserCompleteModel, // T√™n c√≥ th·ªÉ l√† 'RelatedUserModel' t√πy generator
} from '@/zod/generated/user';

// V√≠ d·ª• v·ªÅ m·ªôt output t√πy bi·∫øn: Profile c√¥ng khai.
// Schema n√†y s·∫Ω ƒë∆∞·ª£c d√πng trong .output() c·ªßa router n·∫øu c·∫ßn.
export const UserPublicProfileSchema = BaseUserModel.omit({
  email: true,
  role: true,
  createdAt: true,
});
```

#### **`service.ts` (Ch·∫•t l∆∞·ª£ng & T·ªëi gi·∫£n)**

```typescript
// file: models/user/service.ts
import type { PrismaClient } from '@prisma/client'; // Ch·ªâ import type
import type { RegisterUserInput, UpdateUserRoleInput } from './input';

// Service class nh·∫≠n prisma instance qua constructor
export class UserService {
  private readonly prisma: PrismaClient;

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
  }

  // C√°c ph∆∞∆°ng th·ª©c b√¢y gi·ªù s·∫Ω d√πng this.prisma
  public async register(input: RegisterUserInput) {
    // ... logic nghi·ªáp v·ª• ...
    return this.prisma.user.create({
      data: input,
    });
  }

  public async updateUserRole(input: UpdateUserRoleInput) {
    // ... logic ki·ªÉm tra quy·ªÅn ...
    return this.prisma.user.update({
      where: { id: input.userId },
      data: { role: input.role },
      select: { id: true, role: true },
    });
  }
}
```

#### **`router.ts` (B·ªë c·ª•c & K·ª∑ lu·∫≠t)**
```typescript
// file: models/user/router.ts
import { createTRPCRouter, protectedProcedure, publicProcedure } from '@/server/trpc';
import { UserService } from './service'; // Import class, kh√¥ng ph·∫£i instance
import { userMeta } from './meta';
import { registerUserSchema, updateUserRoleSchema } from './input';
import { UserModel, UserRoleOutputSchema } from './output';

export const userRouter = createTRPCRouter({
  register: publicProcedure
    .meta(userMeta.register)
    .input(registerUserSchema)
    .output(UserModel)
    .mutation(({ input, ctx }) => {
      // Kh·ªüi t·∫°o service v·ªõi prisma t·ª´ context
      const userService = new UserService(ctx.prisma);
      return userService.register(input);
    }),

  updateRole: protectedProcedure
    .meta(userMeta.updateRole)
    .input(updateUserRoleSchema)
    .output(UserRoleOutputSchema)
    .mutation(({ input, ctx }) => {
      // ctx ch·ª©a c·∫£ th√¥ng tin user v√† prisma client
      // ... logic ki·ªÉm tra quy·ªÅn v·ªõi ctx.user ...

      // Kh·ªüi t·∫°o service v·ªõi prisma t·ª´ context
      const userService = new UserService(ctx.prisma);
      return userService.updateUserRole(input);
    }),
});
```
#### **`meta.ts` (T·ª± ƒë·ªông)**
*Quy t·∫Øc: Cung c·∫•p metadata ƒë·ªÉ c√°c c√¥ng c·ª• kh√°c (OpenAPI) c√≥ th·ªÉ t·ª± ƒë·ªông h√≥a.*

```typescript
// models/user/meta.ts
import type { OpenApiMeta } from 'trpc-openapi';

export const userMeta = {
  register: {
    openapi: {
      method: 'POST',
      path: '/users/register',
      tags: ['User'],
      summary: 'ƒêƒÉng k√Ω m·ªôt ng∆∞·ªùi d√πng m·ªõi',
    },
    mcp: {
      enabled: true,
      name: 'user-register',
      description: 'ƒêƒÉng k√Ω m·ªôt ng∆∞·ªùi d√πng m·ªõi'
    }
  } as OpenApiMeta,
};
```

#### **Redis Queue System Examples**

##### **`queue/queue.service.ts` (Domain-specific Queue Service)**
*Quy t·∫Øc: Wrap QueueService v·ªõi business logic c·ª• th·ªÉ cho domain.*

```typescript
// models/knowledge/queue/queue.service.ts
import { queueService, QueueConfig } from '../../queue';
import type { KnowledgeStreamingJobData, QueueJobOptions } from '../../queue';
import type { KnowledgeReindexRequest } from '../types';
import { v4 as uuidv4 } from 'uuid';
import logger from '../../../shared/utils/logger';

/**
 * Knowledge Queue Service
 * @see core/models/queue/queue.service.ts - Base QueueService implementation
 */
export class KnowledgeQueueService {
  private static instance: KnowledgeQueueService;

  public static getInstance(): KnowledgeQueueService {
    if (!KnowledgeQueueService.instance) {
      KnowledgeQueueService.instance = new KnowledgeQueueService();
    }
    return KnowledgeQueueService.instance;
  }

  /**
   * Th√™m job streaming reindex cho source
   * @see core/models/knowledge/queue/queue.service.ts:27-86
   */
  public async addSourceStreamingReindexJob(
    request: KnowledgeReindexRequest,
    options: QueueJobOptions = {}
  ): Promise<string> {
    const requestId = request.requestId || uuidv4();
    
    const jobData: KnowledgeStreamingJobData = {
      sourceId: request.sourceId!,
      operation: 'source_reindex',
      requestId,
      priority: request.priority === 'high' ? 10 : 5,
      metadata: {
        originalRequest: request,
        createdAt: new Date(),
      },
    };

    const job = await queueService.addJob(
      QueueConfig.queues.KNOWLEDGE_STREAMING,
      'source-streaming-reindex',
      jobData,
      { priority: jobData.priority, ...options }
    );

    logger.info({
      jobId: job.id,
      sourceId: request.sourceId,
      requestId,
    }, 'üìã Source streaming reindex job added to queue');

    return job.id!;
  }
}
```

##### **`queue/{job-name}.worker.ts` (Worker Implementation)**
*Quy t·∫Øc: Worker ph·∫£i c√≥ progress tracking ƒë·ªÉ tr√°nh job lock issues.*

```typescript
// models/knowledge/queue/streaming-reindex.worker.ts
import { Worker } from 'bullmq';
import { queueService, workerManager, QueueConfig } from '../../queue';
import type { KnowledgeStreamingJobData, TypedJob } from '../../queue';
import { KnowledgeService } from '../service/service';
import { prisma } from '../../../prisma/client';
import logger from '../../../shared/utils/logger';

/**
 * Knowledge Streaming Reindex Worker
 * @see core/models/knowledge/queue/streaming-reindex.worker.ts:12-39
 */
export class KnowledgeStreamingWorker {
  private worker: Worker | null = null;
  private readonly knowledgeService: KnowledgeService;

  constructor() {
    this.knowledgeService = KnowledgeService.getInstance(prisma);
  }

  public start(concurrency = 1): void {
    if (this.worker) {
      logger.warn({}, '‚ö†Ô∏è Knowledge streaming worker is already running');
      return;
    }

    this.worker = queueService.createWorker(
      QueueConfig.queues.KNOWLEDGE_STREAMING,
      this.processJob.bind(this),
      concurrency
    );

    workerManager.registerWorker('knowledge-streaming', this.worker);
    logger.info({ concurrency }, 'üöÄ Knowledge streaming worker started');
  }

  /**
   * X·ª≠ l√Ω job v·ªõi progress tracking ƒë·ªÉ tr√°nh lock renewal errors
   * @see core/models/knowledge/queue/streaming-reindex.worker.ts:44-100
   */
  private async processJob(job: TypedJob<KnowledgeStreamingJobData>): Promise<any> {
    const startTime = Date.now();
    
    // Report initial progress ƒë·ªÉ maintain job lock
    await job.updateProgress({ 
      percentage: 0, 
      status: 'Starting reindex process',
      startTime: Date.now()
    });

    try {
      // ... x·ª≠ l√Ω job v·ªõi progress updates ƒë·ªãnh k·ª≥ ...
      
      await job.updateProgress({
        percentage: 50,
        status: 'Processing documents...',
      });

      // ... ti·∫øp t·ª•c x·ª≠ l√Ω ...

      await job.updateProgress({
        percentage: 100,
        status: 'Completed successfully',
        endTime: Date.now(),
        duration: Date.now() - startTime
      });

      return { success: true, duration: Date.now() - startTime };

    } catch (error) {
      logger.error({
        jobId: job.id,
        error: error instanceof Error ? error.message : String(error)
      }, '‚ùå Job processing failed');

      throw error;
    }
  }
}
```

##### **`queue/index.ts` (Queue Exports)**
*Quy t·∫Øc: Export t·∫•t c·∫£ queue services v√† workers c·ªßa domain.*

```typescript
// models/knowledge/queue/index.ts
export { KnowledgeQueueService } from './queue.service';
export { KnowledgeStreamingWorker } from './streaming-reindex.worker';

// Kh·ªüi t·∫°o workers khi import
import { KnowledgeStreamingWorker } from './streaming-reindex.worker';
import { KNOWLEDGE_QUEUE_CONFIG } from '../config';

const streamingWorker = new KnowledgeStreamingWorker();
streamingWorker.start(KNOWLEDGE_QUEUE_CONFIG.STREAMING_CONCURRENCY);
```

---

### **Ph·∫ßn IV: Quy t·∫Øc Testing**

1.  **Ch·∫•t l∆∞·ª£ng:** M·ªçi logic quan tr·ªçng v√† c√°c lu·ªìng nghi·ªáp v·ª• ch√≠nh ƒë·ªÅu ph·∫£i c√≥ test.
2.  **C·∫•u tr√∫c:** Tu√¢n th·ªß nghi√™m ng·∫∑t c·∫•u tr√∫c 3 l·ªõp:
    *   `1-unit/`: Test logic thu·∫ßn t√∫y. **PH·∫¢I MOCK** Prisma.
    *   `2-integration/`: Test t∆∞∆°ng t√°c v·ªõi DB th·∫≠t. **KH√îNG MOCK** Prisma.
    *   `3-e2e/`: Test to√†n b·ªô lu·ªìng nghi·ªáp v·ª•.
3.  **C√¥ng c·ª• & K·ª∑ lu·∫≠t:**
    *   S·ª≠ d·ª•ng `Testcontainers` ƒë·ªÉ t·∫°o m√¥i tr∆∞·ªùng DB nh·∫•t qu√°n cho Integration Test.
    *   S·ª≠ d·ª•ng [shared util test](/core/shared/test-utils/)
    *   S·ª≠ d·ª•ng [Fabbrica](/core/shared/generated/fabbrica) v√† `@faker-js/faker` ƒë·ªÉ t·∫°o d·ªØ li·ªáu test m·ªôt c√°ch t·ª± ƒë·ªông v√† c√≥ c·∫•u tr√∫c.
    *   **Queue Testing:** S·ª≠ d·ª•ng Redis Testcontainers cho queue integration tests, mock QueueService cho unit tests 

```

---
